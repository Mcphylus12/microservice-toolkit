using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Communications.CodeGeneration
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var types = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: IsRequestHandler,
                transform: GetHandlerInfo)
                .Collect();


            context.RegisterSourceOutput(types, GenerateCode);
        }

        private void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> types)
        {
            List<(string serviceType, string concreteType, ITypeSymbol requestType, bool hasResponse)> serviceTypes = new List<(string, string, ITypeSymbol, bool)>();

            foreach (var type in types)
            {
                var concreteName = type.ToDisplayString();

                var interfacee = type.Interfaces.Single(interfacee =>
                    interfacee.Name == "IRequestHandler" || interfacee.Name == "IMessageHandler");

                var serviceType = interfacee.ToDisplayString();

                var request = interfacee.TypeArguments[0];
                serviceTypes.Add((serviceType, concreteName, request, interfacee.TypeArguments.Length > 1));
            }

            var switchBody = serviceTypes.Select(s =>
            {
                var responseReturn = s.hasResponse ? "return " : string.Empty;
                var nullReturn = !s.hasResponse ? "return null;" : string.Empty;

                return
$@"
            case ""{s.requestType.Name}"":
                {{
                    var service = ActivatorUtilities.CreateInstance<{s.concreteType}>(_serviceProvider);
                    var request = await deserialiseType(typeof({s.requestType.ToDisplayString()}));
                    {responseReturn}await service.HandleAsync(({s.requestType.ToDisplayString()})request);
                    {nullReturn}
                }}
";
            });

            context.AddSource("HandlerRegistration.g.cs",
@$"// <auto-generated />
using Microsoft.Extensions.DependencyInjection;
using Communication.Abstractions.Registration;

#nullable enable
namespace Communication.Abstractions.Registration;

public static class HandlerRegistration
{{
    public static void RegisterHandlers(IServiceCollection services)
    {{
        services.AddTransient<IResolver, Resolver>();
    }}
}}


public class Resolver : IResolver
{{
    private readonly IServiceProvider _serviceProvider;

    public Resolver(IServiceProvider serviceProvider)
    {{
        _serviceProvider = serviceProvider;
    }}

    public async Task<object?> Resolve(string messageType, Func<Type, Task<object>> deserialiseType)
    {{
        switch (messageType)
        {{
            {string.Join("\n\t\t\t", switchBody)}
            default: throw new NotSupportedException();
        }}
    }}
}}
");
        }

        private bool IsRequestHandler(SyntaxNode node, CancellationToken ct)
        {
            if (node is not BaseTypeSyntax bts)
                return false;
            if (bts.Type is GenericNameSyntax gns)
            {
                return gns.Identifier.Text == "IRequestHandler"
                    || gns.Identifier.Text == "IMessageHandler"
                    //|| gns.Identifier.Text == "IRequest"
                    ;
            }
            //else if (bts.Type is SimpleNameSyntax sns)
            //{
            //    return sns.Identifier.Text == "IRequest"
            //        || sns.Identifier.Text == "IMessage";
            //}

            return false;
        }

        private ITypeSymbol GetHandlerInfo(GeneratorSyntaxContext context, CancellationToken token)
        {
            var baseTypeSyntax = (BaseTypeSyntax)context.Node;

            if (baseTypeSyntax.Parent.Parent is not ClassDeclarationSyntax classDef)
                return null;

            return context.SemanticModel.GetDeclaredSymbol(classDef);
        }
    }
}
