using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Communications.CodeGeneration
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var types = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: IsRequestHandler,
                transform: GetHandlerInfo)
                .Collect();


            context.RegisterSourceOutput(types, GenerateCode);
        }

        private void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> types)
        {
            List<(string serviceType, string concreteType, ITypeSymbol requestType, bool hasResponse)> serviceTypes = new List<(string, string, ITypeSymbol, bool)>();

            foreach (var type in types)
            {
                var concreteName = type.ToDisplayString();

                var interfacee = type.Interfaces.Single(interfacee =>
                    interfacee.Name == "IRequestHandler" || interfacee.Name == "IMessageHandler");

                var serviceType = interfacee.ToDisplayString();

                var request = interfacee.TypeArguments[0];
                serviceTypes.Add((serviceType, concreteName, request, interfacee.TypeArguments.Length > 1));
            }

            var dicionarySetup = serviceTypes.Select(s =>
            {
                var responseReturn = s.hasResponse ? "return " : string.Empty;
                var nullReturn = !s.hasResponse ? "return null;" : string.Empty;

                return
$@"
        _handlers[""{s.requestType.Name}""] = async deserialise =>
        {{
            var service = ActivatorUtilities.CreateInstance<{s.concreteType}>(serviceProvider);
            var request = await deserialise(typeof({s.requestType.ToDisplayString()}));
            {responseReturn}await service.HandleAsync(({s.requestType.ToDisplayString()})request);
            {nullReturn}
        }};
";
            });

            context.AddSource("HandlerRegistration.g.cs",
@$"// <auto-generated />
using Microsoft.Extensions.DependencyInjection;
using Communication.Abstractions.Registration;

#nullable enable
namespace Communication.Abstractions.Registration;

public static class HandlerRegistration
{{
    public static void RegisterHandlers(IServiceCollection services)
    {{
        services.AddTransient<IResolver, Resolver>();
    }}
}}


public class Resolver : IResolver
{{
    private delegate Task<object?> Handle(IResolver.Deserialise deserialise);
    private readonly Dictionary<string, Handle> _handlers;

    public Resolver(IServiceProvider serviceProvider)
    {{
        _handlers = new Dictionary<string, Handle>();

        {string.Join("\n", dicionarySetup)}
    }}

    public Task<object?> Resolve(string messageType, IResolver.Deserialise deserialiseType)
    {{
        if (_handlers.TryGetValue(messageType, out var handler))
        {{
            return handler(deserialiseType);
        }}

        throw new NotSupportedException();
    }}
}}
");
        }

        private bool IsRequestHandler(SyntaxNode node, CancellationToken ct)
        {
            if (node is not BaseTypeSyntax bts)
                return false;
            if (bts.Type is GenericNameSyntax gns)
            {
                return gns.Identifier.Text == "IRequestHandler"
                    || gns.Identifier.Text == "IMessageHandler"
                    //|| gns.Identifier.Text == "IRequest"
                    ;
            }
            //else if (bts.Type is SimpleNameSyntax sns)
            //{
            //    return sns.Identifier.Text == "IRequest"
            //        || sns.Identifier.Text == "IMessage";
            //}

            return false;
        }

        private ITypeSymbol GetHandlerInfo(GeneratorSyntaxContext context, CancellationToken token)
        {
            var baseTypeSyntax = (BaseTypeSyntax)context.Node;

            if (baseTypeSyntax.Parent.Parent is not ClassDeclarationSyntax classDef)
                return null;

            return context.SemanticModel.GetDeclaredSymbol(classDef);
        }
    }
}
